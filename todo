Next MVP:
	✔ have current system read full request from buffer @done(23-08-13 17:40)
	✔ send valid mockup response to client @done(23-08-19 17:59)
	✔ Make final objects for request and response with only getter and setter @done(23-09-05 15:09)
	✔ Create mockup of req/resp filler to produce a valid result with the webserv @done(23-09-05 15:09)
	☐ then, for the rest of the dev cycle, we can implement "real" operations one by one, without breaking anything
	☐ start implementing methods prototype
	☐ send a variable response to client, with just a specific text response depending on the request : "i received a GET/PUT/etc request"(will need request parsing)
	☐ reponse header constructor, simple step by simple step(biggest unknown for now)
	☐ after all that, it's probably possible to start automating testing, particular cases by particular cases (status, methods, CGI)
	✔ exec CGI (should not be terribly hard,it's an established process) @done(23-10-15 17:59)
	☐ manage exceptions and error (http code, etc.)
	☐ error page by default
	☐ split listen arg if IP and Port
	☐ CGI
	☐ routing, autoindex, etc.

TCP:

	✔ mockup parser to print a vector of char @done(23-08-15 15:58)
	✔ Converter from string to int for ip @done(23-10-15 17:58)
	☐ loop of server ports binding to epoll struct (currently only 1)
	✔ protection with throw @done(23-08-13 17:40)
	✔ read_from_client function @done(23-08-12 17:58)
	✔ write_to_client function @done(23-08-12 18:19)
	✔ bool checker is_new_connection @done(23-08-12 18:23)
	✔ send_response @done(23-08-12 18:26)
	☐ is_request_over() //needed for read_from_client
	✔ is_response_over() @done(23-10-17 16:00)
	//current implementation is not working
	✔ update_connection_status() !! @done(23-08-15 15:58)
	☐ is_connection_over
	//not sure it's totally needed, there should be a timeout somewhere right?
	//☐ chunked encoding will need to be implemented to manage files (pictures/gif/sound/etc.) chunked request for PUT media, chunked response for GET requests
	✔ if a read/write to client return an error, the client should be removed (and it's buffer purged too) @done(23-10-17 18:26)
	✔ if read/write return an error, it should check both 0 and -1 @done(23-10-17 18:26)

Configuration:
	☐ possibility to setup multiple server with different ports and hostname
	☐ possibility to setup a default error page
	☐ manage a request body size limit
	☐ setup routes to different directories
	☐ limit valid methods depending on routes used
 Buffer:
	☐ increment_response_count
	//currently work but is completly useless,
	
	//maybe it should count an objective number of send and an effective num, and use the differenece as a stop condition
	✔ bool checker for buffer @done(23-10-17 17:23)
	✔ char vector getter for usage @done(23-08-13 17:40)
	✔ buffer editor @done(23-10-16 14:19)

Control/exec:
	☐ check if request parsing failed and send a 400 error
	☐ maybe a simple method to create a simple error response
	☐ check if error is 404 and use the defined error page in that case (just hardcoded body with int variable and approriate message, same for status code)
	☐ path editor to find real path from requested one
	☐ need a check somewhere to determine if the requested server is accessed from the correct port

Methods:
	✔ GET @done(23-10-15 17:59)
	✔ POST @done(23-10-15 17:59)
	✔ DELETE @done(23-10-15 17:59)
	☐ UNKNOWN methods should be managed without crashes
	☐ status codes for various actions should be correct
	✔ we can POST a file and GET it back after @done(23-10-19 18:26)
	☐ Is_CGI method needed
	✔ request object @done(23-10-19 18:26)
	✔ main method to call all methods (exec in model) @started(23-10-16 14:23) @done(23-10-19 18:26) @lasted(3d4h3m47s)
	☐ request constructor/parser
	✔ response constructor @done(23-10-19 18:26)
CGI:
	☐ cGI  should be run in the correct directory
	☐ CGI work with POST and GET methods
	☐ CGI errors should be managed properly (files with error, infinite loop, etc.)
Browser:
	☐ browser should be able to conect to server with "network" tab
	☐ trying a wrong URL should be managed properly
	☐ accessing a directory should be managed too
	☐ try a redirect URL??(no idea what that mean here)
Port:
	☐ if multiple website uses multiple ports, the browser see the expected website
	☐ if config try t use same port multiple times, it should not work
	☐ if multiple webserv with different config use same port, the first ne should probably work
	and the next one shouldn't
Siege:
	☐ learn how to use siege
	//use getline or ifstream to read the file (GET) or the pipe after execve
	//remove use of read outside of TCP class -> (currently in file manip and cgi exec)
Note:
	//adding pipe fd to epoll manager seems absolutly disgusting
	//and way more complex than needed, but possible in theory
	//it sound like a super bad practice though so i'm not ding that
	 